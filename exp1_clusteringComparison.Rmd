---
title: "Cluster comparison of spatial spleen data"
author: "Sara Gosline"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
library(BayesSpace)
library(ggplot2)
library(dplyr)
library(tidyr)

library(RColorBrewer)
library(cowplot)
  
```

## Format data
First grab data and format into single table. Evaluate distributions of values. There are clearly different distributions when we median center the data.

```{r get data, message=F,warning=F}
library(dplyr)
library(purrr)
library(devtools)
#library(MSnSet.utils)
if(!require(MSnSet.utils))
  devtools::install_github('PNNL-Comp-Mass-Spec/MSnSet.utils')

library(ggplot2)
library(ggfortify)
library(cowplot)

##define metadata
metadata <- isletMeta%>%
   select(IsletStatus,IsletOrNot,Plex,`Grid Number`)%>%
   tibble::rownames_to_column('Spot')
 
## define proteomic data
prottab <- do.call(rbind,lapply(crosstabList,function(x){
   newx<-x%>%
   tidyr::separate(feature,into=c('id','upid','protein'),
                   sep='\\|')%>%
   dplyr::select(-c(id,upid))
   #ibble::column_to_rownames('protein')
   newx<-newx%>%
     tidyr::pivot_longer(2:ncol(newx),names_to='Spot', values_to='logRatio')%>%
     tidyr::separate(Spot,into=c('Image','S','Xcoord','Ycoord'),sep='_',remove=F)%>%
     dplyr::select(-S)
   newx
   })
)%>%
  left_join(metadata)
 
##define phosphoproteomic data
phostab
 
##now save the fulltab to supp data table 1
 
write.table(fulltab,'suppTable1.csv',sep=',',quote=F,row.names=F)
```

Now we have a sense of how the data are distributed. Obviously this varies based on the normalization that we use in the original data. This will help guide our future analysis.


```{r visualize data}
library(Matrix)

counts<-fulltab%>%
  dplyr::select(Spot,protein,logRatio)%>%
  tidyr::pivot_wider(values_from=logRatio,names_from=Spot)%>%
  tibble::column_to_rownames('protein')


norm.counts<-normtab%>%
  dplyr::select(Spot,protein,logRatio)%>%
  tidyr::pivot_wider(values_from=logRatio,names_from=Spot)%>%
  tibble::column_to_rownames('protein')

colData <- fulltab%>%
    dplyr::select(Spot,Image,Xcoord,Ycoord,IsletStatus,IsletOrNot)%>%
  #distinct()%>%
#  tidyr::separate(Coords,into=c('S','col','row'),sep='_')%>%
  mutate(col=as.numeric(Xcoord),row=as.numeric(Ycoord))%>%
  distinct()

rowData <- data.frame(protein=rownames(counts))


p1<-ggplot(fulltab,aes(x=logRatio,fill=as.factor(`Grid Number`), shape=IsletStatus,alpha=0.5))+
  geom_density()+
  facet_grid(Image~.)+
  scale_fill_manual(values=RColorBrewer::brewer.pal(9,'Set1'))

p2<-ggplot(normtab,aes(x=logRatio,fill=as.factor(`Grid Number`), shape=IsletStatus,alpha=0.5))+
  geom_density()+
  facet_grid(Image~.)+
  scale_fill_manual(values=RColorBrewer::brewer.pal(9,'Set1'))

p3<-ggplot(fulltab,aes(x=logRatio,fill=IsletStatus,alpha=0.5))+geom_density()+facet_grid(Image~.)+scale_fill_manual(values=RColorBrewer::brewer.pal(9,'Set1'))

p4<-ggplot(normtab,aes(x=logRatio,fill=IsletStatus,alpha=0.5))+geom_density()+facet_grid(Image~.)+scale_fill_manual(values=RColorBrewer::brewer.pal(9,'Set1'))



  res=cowplot::plot_grid(p1,p3,p2,p4)
  print(res)
  
  ggsave('normalizedCountDistribution.pdf',res,height=8,width=11)

```


## PCA
Here we will use PCA to compare how samples are distributed based on metadata.


## KMeans clustering

Determine the the optimal number of clusters and assign each sample toa  cluster, then re-plot PCA with cluster labels.

## BayesSpace

First format as `SingleCellExperiment` to make sure that the data can be fed in to BayesSpace. Add in in the known labels and coordinates.


## Cluster and plotting function

We put all the functionality into a single function for now.
Here we do preprocessing, which works, cluster analysis, the clustering. We iterate through 1-4 clusters, but generally always use 3 since that is what we are expecting. However, it seems that 4 also works.  

```{r spatial process, echo=FALSE}


kmeanClusterPlot<-function(sce,prefix){
  
}

bayesSpaceClusterPlot<-function(sce,prefix){
  
  
  #pre-process data
  set.seed(102)
  panc <- spatialPreprocess(sce, platform="ST", 
                              n.PCs=7, n.HVGs=1000, log.normalize=FALSE)

  ##identify optimal number of cluseters
  panc <- qTune(panc, qs=seq(1, 4), platform="ST", d=5)
  qPlot(panc)
  
  ##get optimal from data above. how do i do this?
  optimal=2
  
  panc2 <- spatialCluster(panc, q=optimal, platform="ST", d=5,
                           init.method="kmeans", model="normal", gamma=2,
                           nrep=2000, burn.in=200,
                           save.chain=TRUE)

  
  pance2 <-spatialEnhance(panc2,q=optimal,d=5)  

  
  cols<- RColorBrewer::brewer.pal(6,'Dark2')[c(1,2,3,6,4,5)]

  c0=clusterPlot(panc,
              palette=cols,
              label='IsletStatus')+
    ggtitle(paste('Image',prefix,'labels'))
    
    c1=clusterPlot(panc2,
              palette=cols)+
    ggtitle(paste('Image',prefix,'data'))
  
  
  return(panc2)

}


#' loadData function that takes combined data and xycoords and formats into 
#' singleCellExperiment
loadData<-function(colData){
  
  #print(image)
  i1_spots<-subset(colData,Image==image)%>%
    tibble::column_to_rownames('Spot')
  
  cmat <- as.matrix(countdat)#[,rownames(i1_spots)])
  #print(dim(cmat))
  nas <- which(apply(cmat,1,function(x) all(is.na(x))))
  if(length(nas)>0)
    cmat <- cmat[-nas,]
  #print(dim(cmat))
  rowD <- rowData[rownames(cmat),]
  
  sce <- SingleCellExperiment(assays=list(logcounts=as(cmat, "dgCMatrix")),
                            rowData=rowD,
                            colData=i1_spots)
  
  
  
  return(sce)
}
#

#' plotDataPerImage
#' This function tunes the cluster, identifies the best number of cluster
plotDataPerImage<-function(image,countdat,prefix=''){

  
#  pance3 <- spatialEnhance(panc3,q=3,d=5)
#  
#  pance4 <- spatialEnhance(panc4,q=4,d=5)

  
    
   c2=clusterPlot(panc3,
              palette=cols)+
    ggtitle(paste('Image',image,'data'))
  
  c3=clusterPlot(panc4,
              palette=cols)+
    ggtitle(paste('Image',image,'data'))
  
    c4=clusterPlot(panc5,
              palette=cols)+
    ggtitle(paste('Image',image,'data'))
    
      c5=clusterPlot(panc6,
              palette=cols)+
    ggtitle(paste('Image',image,'data'))
 # c4=clusterPlot(pance4,
#              palette=cols)+
#    ggtitle(paste('Image',image,'subspot'))

  res=cowplot::plot_grid(c0,c1,c2,c3,c4,c5)
  print(res)

  ggsave(paste0(prefix,'Islet',image,'.pdf'),res)
  ggsave(paste0(prefix,'Islet',image,'.png'),res)

  return(panc)
}


```

Now we can iterate over each of the spots. To see if they agree with our annotations. 

## Original images

```{r cluster, message=F,warning=F}

scObjs<-lapply(unique(colData$Image),function(x) plotDataPerImage(x,counts,'Un-normalized'))

##just do this manually

accuracy <- rbind(data.frame(image=c('0','10','1','2','3','4','7'),
                       TP=c(1,1,1,1,1,1,1),
                       FP=c(0,5,5,3,0,0,0),
                       FN=c(0,0,0,0,0,0,0),
                       TN=c(8,3,3,5,8,8,8),
                       numClusters=c(2,2,2,2,2,2,2)),
                  data.frame(image=c('0','10','1','2','3','4','7'),
                       TP=c(1,1,1,1,1,1,1),
                       FP=c(0,4,0,0,0,0,0),
                       FN=c(0,0,0,0,0,0,0),
                       TN=c(8,3,8,8,8,8,7),
                       numClusters=c(3,3,3,3,3,3,3)),
                  data.frame(image=c('0','10','1','2','3','4','7'),
                       TP=c(1,1,1,1,1,1,1),
                       FP=c(0,4,0,0,0,0,1),
                       FN=c(0,0,0,0,0,0,0),
                       TN=c(8,3,8,8,8,8,7),
                       numClusters=c(4,4,4,4,4,4,4)),
                   data.frame(image=c('0','10','1','2','3','4','7'),
                       TP=c(1,1,1,1,1,1,1),
                       FP=c(0,0,0,0,0,0,0),
                       FN=c(0,0,0,1,0,0,0),
                       TN=c(8,8,8,7,8,8,8),
                       numClusters=c(5,5,5,5,5,5,5)))%>%
  mutate(Specificity=TN/(TN+FP),Sensitivity=TP/(TP+FN))

ggplot(accuracy,aes(y=Specificity,fill=image,
                    x=as.factor(numClusters)))+
  geom_bar(stat='identity',position='dodge')+
  scale_fill_manual(values=RColorBrewer::brewer.pal(7,'Dark2'))                  

ggsave('bayesSpaceIsletId_unnorm.pdf')

```

this is the accuracy of the actual counts

## Normalized images

```{r norm}
scObjs<-lapply(unique(colData$Image),function(x) plotDataPerImage(x,norm.counts,'Normalized'))

norm.accuracy <- rbind(data.frame(image=c('0','10','1','2','3','4','7'),
                       TP=c(1,1,1,1,1,1,1),
                       FP=c(0,5,7,7,0,0,7),
                       FN=c(0,0,0,0,0,0,0),
                       TN=c(8,3,1,1,8,8,1),
                       numClusters=c(2,2,2,2,2,2,2)),
                  data.frame(image=c('0','10','1','2','3','4','7'),
                       TP=c(1,1,1,1,1,1,1),
                       FP=c(0,3,0,1,0,0,0),
                       FN=c(0,0,0,0,0,0,0),
                       TN=c(8,5,8,7,8,8,8),
                       numClusters=c(3,3,3,3,3,3,3)),
                  data.frame(image=c('0','10','1','2','3','4','7'),
                       TP=c(1,1,1,1,1,1,1),
                       FP=c(0,2,3,1,0,0,1),
                       FN=c(0,0,0,0,0,0,0),
                       TN=c(8,6,5,7,8,8,7),
                       numClusters=c(4,4,4,4,4,4,4)),
                   data.frame(image=c('0','10','1','2','3','4','7'),
                       TP=c(1,1,1,1,1,1,1),
                       FP=c(0,2,0,1,0,0,0),
                       FN=c(0,0,0,0,0,0,0),
                       TN=c(8,6,8,7,8,8,8),
                       numClusters=c(5,5,5,5,5,5,5)))%>%
  mutate(Specificity=TN/(TN+FP),
         Sensitivity=TP/(TP+FN))



ggplot(norm.accuracy,aes(y=Specificity,fill=image,
                    x=as.factor(numClusters)))+
  geom_bar(stat='identity',position='dodge')+
  scale_fill_manual(values=RColorBrewer::brewer.pal(7,'Dark2'))                  

ggsave('bayesSpaceIsletId_norm.pdf')
```

To some extent they do, but in other cases they do not. We need to check annotations to ensure they are correct. How can we test to see if they are in agreement? 

